# Loading libraries and count data ---------------------------------------------
library(dplyr)
library(readxl)
library(Seurat)
library(harmony)
library(ggplot2)
library(ggrepel)
library(tidyr)
library(stringr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(scran)
library(scuttle)
library(tibble)
library(edgeR)
library(pheatmap)
library(msigdbr)
library(fgsea)
library(gridExtra)
library(enrichplot)
library(WGCNA)
library(reshape2)

counts <- readRDS("objects/merged_counts.rds")
metadata <- readRDS("objects/metadata_updated.rds")
seurat_obj <- readRDS("objects/seurat_normalized.rds")

counts$gene_name <- make.unique(counts$gene_name)
counts_mat <- as.matrix(counts[, -(1:2)])
rownames(counts_mat) <- counts$gene_name 

combined_score <- readRDS("../pilot-protein/combined_score.rds")
combined_vec <- combined_score$Combined_Score
names(combined_vec) <- combined_score$fiber_id
colnames(seurat_obj) <- seurat_obj$fiber_id
rownames(seurat_obj@meta.data) <- seurat_obj$fiber_id
matched_scores <- combined_vec[colnames(seurat_obj)]
seurat_obj$Combined_Score <- matched_scores

DefaultAssay(seurat_obj) <- "RNA"
seurat_obj <- ScaleData(seurat_obj, features = rownames(seurat_obj))
seurat_obj <- RunPCA(seurat_obj, features = rownames(seurat_obj))
seurat_obj <- RunUMAP(seurat_obj, features = rownames(seurat_obj))
DimPlot(seurat_obj)

pca_df <- data.frame(
  PC1 = Embeddings(seurat_obj[["pca"]])[,1],
  PC2 = Embeddings(seurat_obj[["pca"]])[,2],
  seurat_obj@meta.data
)
var_expl <- (seurat_obj[["pca"]]@stdev^2) / sum(seurat_obj[["pca"]]@stdev^2) * 100

ggplot(pca_df, aes(x = PC1, y = PC2, color = Combined_Score)) +
  geom_point(alpha = 0.7) +
  scale_color_viridis_c(option = "D") +
  theme_bw() +
  labs(
    title = "RNA PCA colored by Combined Score",
    x = paste0("PC1 (", round(var_expl[1], 1), "% variance)"),
    y = paste0("PC2 (", round(var_expl[2], 1), "% variance)")
  )


umap_df <- data.frame(
  UMAP1 = Embeddings(seurat_obj[["umap"]])[,1],
  UMAP2 = Embeddings(seurat_obj[["umap"]])[,2],
  seurat_obj@meta.data
)

ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = Combined_Score)) +
  geom_point(alpha = 0.7) +
  scale_color_viridis_c(option = "D") +
  theme_bw() +
  labs(title = "RNA UMAP colored by Combined Score")

umap_embed <- Embeddings(seurat_obj[["umap"]])

cor_umap1 <- cor(umap_embed[,1], seurat_obj$Combined_Score)
cor_umap2 <- cor(umap_embed[,2], seurat_obj$Combined_Score)

cor_umap1
cor_umap2

# Pseudobulk x sample ----------------------------------------------------------
pseudo_bulk_CS <- readRDS("objects/pseudo_bulk_CS.rds")
sample_info_CS <- readRDS("objects/sample_info_CS.rds")

dge <- DGEList(counts = pseudo_bulk_CS)
dge <- calcNormFactors(dge)

sample_info_CS$group <- factor(sample_info_CS$group, levels = c("C", "S"))
design <- model.matrix(~ group, data = sample_info_CS)

v <- voom(dge, design = design, plot = TRUE)
fit <- lmFit(v, design)
fit <- eBayes(fit)

res_voom <- topTable(fit, coef = "groupS", number = Inf, sort.by = "P")
res_voom$FDR <- p.adjust(res_voom$P.Value, method = "fdr")

expr_mat <- v$E  # genes x samples
pca_res <- prcomp(t(expr_mat), scale. = TRUE)
var_expl <- pca_res$sdev^2 / sum(pca_res$sdev^2) * 100

pca_df <- data.frame(
  Sample = colnames(expr_mat),
  PC1 = pca_res$x[, 1],
  PC2 = pca_res$x[, 2],
  Condition = sample_info_CS$group
)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Condition, label = Sample)) +
  geom_point(size = 4) +
  geom_text_repel(size = 3, show.legend = FALSE) +
  labs(
    title = "PCA of Voom Log2-CPM (Pseudo-bulk Samples)",
    x = paste0("PC1 (", round(var_expl[1],1), "%)"),
    y = paste0("PC2 (", round(var_expl[2],1), "%)")
  ) +
  theme_minimal() +
  scale_color_manual(values = c("C" = "#1f77b4", "S" = "#d62728"))


# Volcano plot
volcano_df <- res_voom %>%
  mutate(
    gene = rownames(res_voom),
    negLogFDR = -log10(adj.P.Val),
    sig = ifelse(adj.P.Val < 0.05 & abs(logFC) > 1, "sig", "ns")
  )

ggplot(volcano_df, aes(x = logFC, y = negLogFDR)) +
  geom_point(aes(color = sig), alpha = 0.7, size = 2) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  scale_color_manual(values = c("sig" = "red", "ns" = "grey")) +
  geom_text_repel(
    data = subset(volcano_df, sig == "sig"),
    aes(label = gene),
    size = 3,
    max.overlaps = 20
  ) +
  labs(
    title = "Volcano — Sick vs Control",
    x = "log2 Fold Change (S / C)",
    y = "-log10(FDR)"
  ) +
  theme_minimal()

# Heatmap for top genes

top_n <- 50  # adjust as needed
top_genes_CS <- rownames(res_voom[order(res_voom$adj.P.Val), ])[1:top_n]

logcpm_CS <- v$E

logcpm_de_CS <- logcpm_CS[top_genes_CS, ]
logcpm_de_scaled_CS <- t(scale(t(logcpm_de_CS)))

annotation_col_CS <- data.frame(group = sample_info_CS$group)
rownames(annotation_col_CS) <- colnames(logcpm_de_scaled_CS)

pheatmap(
  logcpm_de_scaled_CS,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  annotation_col = annotation_col_CS,
  show_rownames = TRUE,
  show_colnames = TRUE,
  scale = "row",
  fontsize = 10,
  main = "Top DE genes (lowest FDR): Sick vs Control"
)

# CvS Pathway analysis (FGSEA) -------------------------------------------------
ranked_genes_CS <- res_voom$logFC
names(ranked_genes_CS) <- rownames(res_voom)
ranked_genes_CS <- ranked_genes_CS[!is.na(ranked_genes_CS)]
ranked_genes_CS <- sort(ranked_genes_CS, decreasing = TRUE)

msig <- readRDS("objects/msig_hallmark.rds")
pathways <- split(msig$gene_symbol, msig$gs_name)

fgsea_CS <- fgsea(pathways = pathways, stats = ranked_genes_CS, nperm = 10000)
fgsea_CS <- fgsea_CS[order(fgsea_CS$padj), ]

fgsea_CS %>%
  slice_head(n = 20) %>%
  ggplot(aes(x = NES, y = reorder(pathway, NES), fill = padj)) +
  geom_col() +
  scale_fill_viridis_c(direction = -1, option = "C") +
  theme_minimal() +
  labs(
    title = "Top Enriched Hallmark Pathways (Sick vs Control)",
    x = "Normalized Enrichment Score (NES)",
    y = "Pathway",
    fill = "FDR"
  )

# Collapse redundancies

fgsea_CS <- fgsea(pathways = pathways, stats = ranked_genes_CS, nperm = 10000) %>%
  arrange(padj)
fgsea_CS_collapsed <- collapsePathways(fgsea_CS,
                                       pathways = pathways,
                                       stats = ranked_genes_CS)
fgsea_CS %>%
  filter(pathway %in% fgsea_CS_collapsed$mainPathways) %>%
  arrange(padj) %>%
  slice_head(n = 15) %>%
  dplyr::select(pathway, NES, padj, size)


# Leading edge genes

top_paths <- fgsea_CS_collapsed$mainPathways

top_fgsea <- fgsea_CS %>%
  filter(pathway %in% top_paths) %>%
  arrange(padj)

top_10_paths <- top_fgsea$pathway[1:10]

leading_genes <- fgsea_CS$leadingEdge[[which(fgsea_CS$pathway == top_10_paths[1])]]
leading_genes

plotGseaTable(pathways[top_10_paths], ranked_genes_CS, top_fgsea, gseaParam = 1)

# Test robustness with multiple libraries and ranking metrics
msig_h <- readRDS("objects/msig_hallmark.rds")
hallmark <- split(msig_h$gene_symbol, msig_h$gs_name)

msig_k <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG_LEGACY")
kegg    <- split(msig_k$gene_symbol, msig_k$gs_name)

msig_r <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:REACTOME")
reactome <- split(msig_r$gene_symbol, msig_r$gs_name)

rank_logFC <- setNames(res_voom$logFC, rownames(res_voom))
rank_tstat <- setNames(res_voom$t,     rownames(res_voom))

rank_logFC <- rank_logFC[!is.na(rank_logFC)]
rank_tstat <- rank_tstat[!is.na(rank_tstat)]

fgsea_h_logFC <- fgsea(pathways = hallmark, stats = sort(rank_logFC, decreasing = TRUE), nperm = 10000)
fgsea_h_tstat <- fgsea(pathways = hallmark, stats = sort(rank_tstat, decreasing = TRUE), nperm = 10000)

fgsea_k_logFC <- fgsea(pathways = kegg,    stats = sort(rank_logFC, decreasing = TRUE), nperm = 10000)
fgsea_r_logFC <- fgsea(pathways = reactome,stats = sort(rank_logFC, decreasing = TRUE), nperm = 10000)

# Compare consistency: which pathways remain significant across metrics?
consistency <- fgsea_h_logFC %>%
  mutate(sig_logFC = padj < 0.05) %>%
  dplyr::select(pathway, NES_logFC = NES, padj_logFC = padj) %>%
  left_join(fgsea_h_tstat %>% mutate(sig_tstat = padj < 0.05) %>%
              dplyr::select(pathway, NES_tstat = NES, padj_tstat = padj),
            by = "pathway")
consistency %>% arrange(padj_logFC)
ggplot(consistency, aes(x = NES_logFC, y = NES_tstat)) +
  geom_point(aes(color = padj_logFC < 0.05 & padj_tstat < 0.05)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(color = "Significant in both", x = "NES (logFC)", y = "NES (t-stat)")
sig_both <- consistency %>%
  filter(padj_logFC < 0.05, padj_tstat < 0.05)

sig_both_names <- sig_both$pathway
hallmark_hits <- sig_both_names
strong_overlap <- data.frame(
  hallmark = hallmark_hits,
  kegg_best = sapply(hallmark_hits, function(h) {
    kegg_paths <- names(kegg)
    overlap <- sapply(kegg_paths, function(k) length(intersect(hallmark[[h]], kegg[[k]])))
    kegg_paths[which.max(overlap)]
  }),
  reactome_best = sapply(hallmark_hits, function(h) {
    reactome_paths <- names(reactome)
    overlap <- sapply(reactome_paths, function(r) length(intersect(hallmark[[h]], reactome[[r]])))
    reactome_paths[which.max(overlap)]
  })
)
heatmap_table <- data.frame(hallmark = hallmark_hits) %>%
  rowwise() %>%
  mutate(
    hall_NES = fgsea_h_logFC$NES[match(hallmark, fgsea_h_logFC$pathway)],
    hall_padj = fgsea_h_logFC$padj[match(hallmark, fgsea_h_logFC$pathway)],
    
    kegg_best = sub(" \\(.*", "", strong_overlap$kegg_best[match(hallmark, strong_overlap$hallmark)]),
    kegg_NES  = fgsea_k_logFC$NES[match(kegg_best, fgsea_k_logFC$pathway)],
    kegg_padj = fgsea_k_logFC$padj[match(kegg_best, fgsea_k_logFC$pathway)],
    
    reactome_best = sub(" \\(.*", "", strong_overlap$reactome_best[match(hallmark, strong_overlap$hallmark)]),
    reactome_NES  = fgsea_r_logFC$NES[match(reactome_best, fgsea_r_logFC$pathway)],
    reactome_padj = fgsea_r_logFC$padj[match(reactome_best, fgsea_r_logFC$pathway)]
  ) %>%
  ungroup()

# NES matrix
nes_matrix <- heatmap_table %>%
  dplyr::select(hallmark, hall_NES, kegg_NES, reactome_NES) %>%
  column_to_rownames("hallmark") %>%
  as.matrix()

# Significance matrix as symbols
sig_matrix <- heatmap_table %>%
  dplyr::select(hallmark, hall_padj, kegg_padj, reactome_padj) %>%
  column_to_rownames("hallmark") %>%
  as.matrix()

# Convert to "*" if significant, else blank
sig_display <- ifelse(sig_matrix < 0.05, "*", "")

# Plot heatmap
pheatmap(
  nes_matrix,
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  display_numbers = sig_display,
  number_color = "black",
  fontsize_number = 20,   
  color = colorRampPalette(c("blue", "white", "red"))(100),
  main = "NES for robust Hallmark pathways across Hallmark, KEGG, Reactome\n'*' indicates padj < 0.05"
)

# # Leading-edge genes
# top_paths <- sig_both_names 
# leading_edges <- fgsea_h_logFC %>%
#   filter(pathway %in% top_paths) %>%
#   dplyr::select(pathway, leadingEdge)
# 
# leading_edge_genes <- unique(unlist(leading_edges$leadingEdge))
# expr_matrix <- as.matrix(GetAssayData(seurat_obj, slot = "data"))
# expr_le <- expr_matrix[leading_edge_genes, ] 
# 
# expr_le_scaled <- t(scale(t(expr_le)))
# 
# pheatmap(expr_le_scaled, cluster_rows = TRUE, cluster_cols = TRUE,
#          main = "Leading-edge genes driving top pathways")
# 
# library(GSVA)
# 
# expr_matrix <- as.matrix(GetAssayData(seurat_obj, slot = "data"))
# 
# expr_matrix <- expr_matrix[rowSums(expr_matrix) > 0, ]
# expr_matrix <- expr_matrix[apply(expr_matrix, 1, var) > 0, ]
# 
# le_gene_sets <- setNames(leading_edges$leadingEdge, leading_edges$pathway)
# 
# expr_matrix_filtered <- expr_matrix[rowSums(expr_matrix) > 0 & apply(expr_matrix, 1, var) > 0, ]
# 
# le_gene_sets_filtered <- lapply(le_gene_sets, function(g) intersect(g, rownames(expr_matrix_filtered)))
# le_gene_sets_filtered <- le_gene_sets_filtered[sapply(le_gene_sets_filtered, length) > 0]
# 
# param_ssgsea <- ssgseaParam(
#   exprData = expr_matrix_filtered, 
#   geneSets = le_gene_sets_filtered,   
#   minSize  = 1,
#   maxSize  = 500
# )
# 
# pathway_scores <- gsva(param_ssgsea, verbose = TRUE)
# 
# dim(pathway_scores)
# head(pathway_scores[, 1:5])
# 
# sample_metadata <- data.frame(
#   Condition = seurat_obj$group
# )
# 
# rownames(sample_metadata) <- colnames(pathway_scores)
# 
# heat <- pheatmap(
#   pathway_scores,
#   cluster_rows = TRUE,
#   cluster_cols = TRUE,
#   annotation_col = sample_metadata,
#   scale = "row",  # centers and scales each pathway across samples
#   show_colnames = FALSE
# )
# 

# Heatmap of top genes ---------------------------------------------------------

logcounts_mat <- as.matrix(GetAssayData(seurat_obj, slot = "data"))
logcounts_top <- logcounts_mat[top_genes_CS, , drop = FALSE]

logcounts_top_scaled <- t(scale(t(logcounts_top)))
colnames(logcounts_top_scaled) <- colnames(logcounts_top)  

cell_meta <- seurat_obj@meta.data
annotation_col <- cell_meta %>%
  dplyr::select(group, sample)
rownames(annotation_col) <- colnames(logcounts_top_scaled)

heat <- pheatmap(
  logcounts_top_scaled,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  annotation_col = annotation_col,
  show_rownames = TRUE,
  show_colnames = FALSE,
  scale = "row",
  fontsize = 10,
  main = "Per-cell expression of top DE genes (lowest FDR)"
)

# Look at top left branch
gene_clusters <- cutree(heat$tree_row, k = 10)

table(gene_clusters)
selected_genes <- names(gene_clusters)[gene_clusters == 1]
selected_genes_in_res <- intersect(selected_genes, rownames(res_voom))
res_selected <- res_voom[selected_genes_in_res, ]
res_selected <- res_selected[order(res_selected$FDR), ]
res_selected

# Cluster extraction -----------------------------------------------------------

col_tree <- heat$tree_col
branches <- cutree(col_tree, k = 8)
cells_branch2_8 <- names(branches)[branches %in% c(2, 8)]
table(seurat_obj$sample[cells_branch2_8])
table(seurat_obj$group[cells_branch2_8])

rownames(seurat_obj@meta.data) <- seurat_obj$fiber_id

seurat_obj$in_cluster <- ifelse(rownames(seurat_obj@meta.data) %in% cells_branch2_8, "cluster", "other")

Idents(seurat_obj) <- "in_cluster"

table(Idents(seurat_obj))  

markers_cluster_all <- FindMarkers(
  seurat_obj,
  ident.1 = "cluster",
  ident.2 = "other",
  logfc.threshold = 0.25,
  min.pct = 0.05,
  test.use = "wilcox"
)

head(markers_cluster_all)
volcano_df <- markers_cluster_all %>%
  dplyr::mutate(
    gene = rownames(markers_cluster_all),
    negLogFDR = -log10(p_val_adj),
    sig = ifelse(p_val_adj < 0.05 & abs(avg_log2FC) > 0.5, "sig", "ns"),
    direction = ifelse(avg_log2FC > 0, "up", "down")
  )

ggplot(volcano_df, aes(x = avg_log2FC, y = negLogFDR)) +
  geom_point(aes(color = sig), alpha = 0.7, size = 2) +
  geom_vline(xintercept = c(-0.5, 0.5), linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  scale_color_manual(values = c("sig" = "red", "ns" = "grey")) +
  geom_text_repel(
    data = subset(volcano_df, sig == "sig" & negLogFDR > 2),
    aes(label = gene),
    size = 3,
    max.overlaps = 20
  ) +
  labs(
    title = "Volcano Plot — Cluster vs Other Cells",
    x = "log2 Fold Change",
    y = "-log10(Adjusted p-value)",
    color = "Significance"
  ) +
  theme_minimal(base_size = 14)

# Pseudobulk to account for donor structure ------------------------------------
cluster_cells <- rownames(seurat_obj@meta.data)[seurat_obj$in_cluster == "cluster"]
Idents(seurat_obj) <- factor(ifelse(colnames(seurat_obj) %in% cluster_cells, "cluster", "other"))
table(Idents(seurat_obj))

counts <- GetAssayData(seurat_obj, slot = "counts")
meta <- seurat_obj@meta.data
all_donors <- unique(meta$sample)

pseudo_bulk_cluster <- sapply(all_donors, function(d) {
  cells <- rownames(meta)[meta$sample == d & meta$in_cluster == "cluster"]
  if(length(cells) == 0) {
    rep(0, nrow(counts))   # placeholder for donors without cluster cells
  } else {
    rowSums(counts[, cells, drop = FALSE])
  }
})

pseudo_bulk_other <- sapply(all_donors, function(d) {
  cells <- rownames(meta)[meta$sample == d & meta$in_cluster == "other"]
  if(length(cells) == 0) {
    rep(0, nrow(counts))
  } else {
    rowSums(counts[, cells, drop = FALSE])
  }
})

pseudo_bulk <- cbind(pseudo_bulk_cluster, pseudo_bulk_other)
colnames(pseudo_bulk) <- paste0(
  rep(all_donors, 2), "_", rep(c("cluster","other"), each = length(all_donors))
)

sample_info <- data.frame(
  sample = colnames(pseudo_bulk),
  donor = rep(all_donors, 2),
  cluster_status = rep(c("cluster","other"), each = length(all_donors))
)
sample_info$cluster_status <- factor(sample_info$cluster_status, levels = c("other","cluster"))
rownames(sample_info) <- sample_info$sample

lib_sizes <- colSums(pseudo_bulk)
zero_lib <- lib_sizes == 0
pseudo_bulk_filtered <- pseudo_bulk[, !zero_lib]
sample_info_filtered <- sample_info[colnames(pseudo_bulk_filtered), ]

cat("Remaining samples for DGEList:", ncol(pseudo_bulk_filtered), "\n")

dge <- DGEList(counts = pseudo_bulk_filtered)
dge <- calcNormFactors(dge)

design <- model.matrix(~ cluster_status, data = sample_info_filtered)
v <- voom(dge, design, plot = TRUE)

corfit <- duplicateCorrelation(v, design, block = sample_info_filtered$donor)
cat("Consensus correlation:", corfit$consensus.correlation, "\n")

fit <- lmFit(v, design, block = sample_info_filtered$donor, correlation = corfit$consensus.correlation)
fit <- eBayes(fit)

top_genes <- topTable(fit, coef = "cluster_statuscluster", number = Inf, sort.by = "P")
top_genes$FDR <- p.adjust(top_genes$P.Value, method = "fdr")
top_genes$negLogFDR <- -log10(top_genes$FDR)
top_genes$sig <- ifelse(top_genes$FDR < 0.05 & abs(top_genes$logFC) > 0.5, "sig", "ns")

top_genes$gene <- rownames(top_genes)

top_label_genes <- top_genes$gene[order(top_genes$FDR)][1:50]

ggplot(top_genes, aes(x = logFC, y = negLogFDR, color = sig)) +
  geom_point(alpha = 0.7) +
  geom_vline(xintercept = c(-0.5, 0.5), linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  geom_text_repel(
    data = subset(top_genes, gene %in% top_label_genes),
    aes(label = gene),
    size = 3,
    max.overlaps = Inf
  ) +
  scale_color_manual(values = c("sig" = "red", "ns" = "grey")) +
  labs(title = "Volcano Plot — Cluster vs Other", x = "log2 Fold Change", y = "-log10(FDR)")

# Sig genes by new pseudobulk


top_sig <- rownames(top_genes[order(top_genes$FDR), ])[1:108]
logcpm <- edgeR::cpm(dge, log = TRUE)
top_sig_mat <- logcpm[top_sig, ]
top_sig_scaled <- t(scale(t(top_sig_mat)))

annotation_col <- data.frame(
  donor = sample_info_filtered$donor,
  cluster_status = sample_info_filtered$cluster_status
)
rownames(annotation_col) <- colnames(top_sig_scaled)

n_donors <- length(unique(annotation_col$donor))

donor_colors <- setNames(
  viridis(n = n_donors, option = "D"),
  unique(annotation_col$donor)
)

cluster_colors <- c(cluster = "red", other = "blue")

annotation_colors <- list(
  donor = donor_colors,
  cluster_status = cluster_colors
)

pheatmap(
  top_sig_scaled,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  annotation_col = annotation_col,
  annotation_colors = annotation_colors,
  show_rownames = TRUE,
  show_colnames = TRUE,
  scale = "row",
  main = "Top 20 DE genes: Cluster vs Other"
)

# Sig genes GO analysis

sig_genes <- rownames(top_genes[top_genes$FDR < 0.05, ])
top_nominal <- rownames(top_genes)[1:108]

ego <- enrichGO(gene = top_nominal,
                OrgDb = org.Hs.eg.db,
                keyType = "SYMBOL",
                ont = "BP",
                pAdjustMethod = "fdr",
                readable = TRUE)
ego_clusters <- pairwise_termsim(ego)
treeplot(ego_clusters, showCategory = 30)

# Sig gene pathways

msig_h <- msigdbr(species = "Homo sapiens", category = "H")
msig_k <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG_LEGACY")
msig_r <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:REACTOME")

ora_h <- enricher(top_nominal, TERM2GENE = msig_h[,c("gs_name","gene_symbol")])
ora_k <- enricher(top_nominal, TERM2GENE = msig_k[,c("gs_name","gene_symbol")])
ora_r <- enricher(top_nominal, TERM2GENE = msig_r[,c("gs_name","gene_symbol")])

plot_top_ora <- function(ora_res, title, top_n = 20) {
  if(is.null(ora_res) || nrow(ora_res) == 0) {
    message(paste("No significant pathways for", title))
    return(NULL)
  }
  
  df <- as.data.frame(ora_res) %>%
    filter(p.adjust < 0.05) %>%  
    mutate(neglogFDR = -log10(p.adjust)) %>%  
    slice_max(order_by = neglogFDR, n = top_n)
  
  ggplot(df, aes(x = neglogFDR, y = reorder(Description, neglogFDR), fill = p.adjust)) +
    geom_col() +
    scale_fill_viridis_c(direction = -1, option = "C") +
    theme_minimal() +
    labs(
      title = title,
      x = "-log10(FDR)",
      y = "Pathway",
      fill = "FDR"
    )
}

plot_top_ora(ora_h, "Top Hallmark Pathways")
plot_top_ora(ora_k, "Top KEGG Pathways")
plot_top_ora(ora_r, "Top Reactome Pathways")

# WGCNA inflammatory fibers ----------------------------------------------------

options(stringsAsFactors = FALSE)
allowWGCNAThreads()

dge <- DGEList(counts = pseudo_bulk_filtered)
dge <- calcNormFactors(dge)
logcpm <- edgeR::cpm(dge, log = TRUE)
logcpm <- logcpm[, colnames(logcpm) %in% sample_info_filtered$sample]

sample_info_filtered <- sample_info_filtered[match(colnames(logcpm), sample_info_filtered$sample), ]
stopifnot(all(colnames(logcpm) == sample_info_filtered$sample))

# -------------------------------
# Top variable genes
# -------------------------------
geneVars <- matrixStats::rowVars(logcpm)
topGenes <- names(sort(geneVars, decreasing = TRUE))[1:3000]
datExpr <- t(logcpm[topGenes, ]) 

traits_correct <- sample_info_filtered %>%
  dplyr::select(sample, donor, cluster_status) %>%
  dplyr::filter(sample %in% rownames(datExpr))
rownames(traits_correct) <- traits_correct$sample
traits_correct$sample <- NULL
stopifnot(all(rownames(traits_correct) == rownames(datExpr))) 

# -------------------------------
# Run WGCNA
# -------------------------------
powers <- 1:20
sft <- pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
softPower <- if(!is.na(sft$powerEstimate)) sft$powerEstimate else 6

net <- blockwiseModules(
  datExpr,
  power = softPower,
  TOMType = "unsigned",
  minModuleSize = 30,
  reassignThreshold = 0,
  mergeCutHeight = 0.25,
  numericLabels = TRUE,
  pamRespectsDendro = FALSE,
  deepSplit = 2,
  maxBlockSize = 3000,
  verbose = 3
)

moduleColors <- labels2colors(net$colors)
MEs <- net$MEs

# -------------------------------
# Create traits_donor
# -------------------------------
traits_donor <- data.frame(
  cluster_num = ifelse(sample_info_filtered$cluster_status == "cluster", 1, 0)
)
rownames(traits_donor) <- rownames(sample_info_filtered)

# Keep only samples present in both MEs and traits
common_samples <- intersect(rownames(MEs), rownames(traits_donor))
MEs <- MEs[common_samples, , drop=FALSE]
traits_donor <- traits_donor[common_samples, , drop=FALSE]
stopifnot(all(rownames(MEs) == rownames(traits_donor)))

# -------------------------------
# Module-trait correlations
# -------------------------------
moduleTraitCor <- cor(MEs, traits_donor, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples = nrow(datExpr))
colnames(moduleTraitCor) <- colnames(traits_donor)
colnames(moduleTraitPvalue) <- colnames(traits_donor)

cor_threshold <- 0.3
pval_threshold <- 0.05

# Identify significant modules
sig_modules <- rownames(moduleTraitCor)[
  abs(moduleTraitCor[, "cluster_num"]) > cor_threshold &
    moduleTraitPvalue[, "cluster_num"] < pval_threshold
]

if(length(sig_modules) == 0) stop("No significant modules found.")

# Map module colors to ME numbers
color_levels <- levels(factor(moduleColors))
color2num <- setNames(seq_along(color_levels)-1, color_levels)

# Map module color → ME number for significant modules
sig_colors <- names(color2num)[color2num %in% as.numeric(gsub("ME","", sig_modules))]

# -------------------------------
# Build hub_list safely
# -------------------------------
color2ME <- sapply(names(color2num), function(col){
  num <- color2num[col]
  grep(paste0("kME", num, "$"), colnames(kME), value = TRUE)
})
mod_labels <- net$colors
names(mod_labels) <- rownames(datExpr)

# For each color, find the ME name
color2ME <- sapply(unique(moduleColors), function(col){
  # get numeric label assigned by WGCNA to this color
  label_num <- unique(net$colors[moduleColors == col])
  paste0("ME", label_num)
})

hub_list <- lapply(names(color2ME), function(col){
  genes <- names(moduleColors)[moduleColors == col]
  ME_name <- color2ME[col]
  kME_col <- grep(ME_name, colnames(kME), value = TRUE)
  if(length(kME_col)==0) return(character(0))
  kME_values <- kME[genes, kME_col]
  kME_values <- kME_values[!is.na(kME_values)]
  head(names(sort(kME_values, decreasing = TRUE)), 10)
})
names(hub_list) <- names(color2ME)

# -------------------------------
# Build final significant module summary
# -------------------------------
module_summary_df <- lapply(sig_colors, function(col){
  num <- color2num[col]
  ME_name <- paste0("ME", num)
  
  # Top hub genes
  hubs <- hub_list[[col]]
  top_hubs <- if(length(hubs) > 0) paste(hubs, collapse = ", ") else NA
  
  # Correlated traits
  cor_vals <- moduleTraitCor[ME_name, , drop=FALSE]
  pvals <- moduleTraitPvalue[ME_name, , drop=FALSE]
  sig <- names(cor_vals)[abs(cor_vals) > cor_threshold & pvals < pval_threshold]
  cor_label <- if(length(sig) > 0) paste0(sig, " (", round(cor_vals[sig],2), ")") else NA
  
  data.frame(
    Module = col,
    ME = ME_name,
    Top_Hub_Genes = top_hubs,
    Correlated_Trait = cor_label,
    Significant = TRUE,
    stringsAsFactors = FALSE
  )
}) |> bind_rows()

module_summary_df

